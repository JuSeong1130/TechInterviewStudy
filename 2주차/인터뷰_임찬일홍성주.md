# 1회차 테크 인터뷰 스터디

## 정보
- 참여 인원 : 임찬일(질문자), 홍성주(답변자)

## 내용

### Q1. JVM의 가비지 컬렉션이 어떻게 돌작하는지 설명하시오

### A1. 답변
가비지 컬렉터에는 마이너 gc가 있고 여기서는 올드 메모리 영역을 담당하고
메이저 GC는 뉴 메모리 영역을 담당합니다.
stop the world가 시작되고 모든 쓰레들 정지시키는 활동을 합니다.
이후 Mark and Sweep가 수행되어 힙 메모리에 위치한 메모리 중 할당 안된 객체를 정리합니다.

### Q&A1. 점수
* 질문자 점수: 3.0 
* 답변자 점수: {최소 1점 ~ 최대 5점. 자신이 답변한 내용면으로나 질문자의 의도를 어느 정도 만족시켰다고 생각하는지 스스로 매기는 점수.} 

### Q&A1. 피드백
- 질문자 피드백: 답변이 개념을 그대로 외워서 답변한다는 느낌을 받음. 개념에 대한 정의를 설명하고 이것들이 어떻게 동작하여 GC가 메모리 관리를 할 수 있는지를 전달해주었으면 좋았겠다고 생각이 됨.
- 답변자 피드백: 
- 기타 피드백: 

### AS1. 개선 답변
{답변 내용. 모든 과정이 끝난 후 답변자가 자신의 답변 내용을 검토하며 느낀 바를 토대로 새롭게 답변을 작성('이렇게 대답했으면 더 좋았을 텐데' 혹은 '새롭게 알게 된 부분에 대해서 다시 답변해봐야겠다' 하는 부분 등). }

새로운 답변 ⬇️⬇️

> JVM 가비지 컬렉터란 JVM에 다이상 사용되지 않는 데이터가 할당되어 메모리를 해제해주는 장치입니다.(GC에 대한 정의 먼저 설명). 즉 참조 되어 있지 않는 객체들을 대상으로 메모리를 해제해 주는 것을 의미합니다. GC 는 일어나는 시점에 따라 크게 Major GC와 MInor GC로 구분 되어 있습니다. Minor GC는 young에 위치한 각각의 영역이 가득차게 되는 경우 발생하고 Major GC는 Old 영역에 이루어지게 됩니다. 공통적으로 GC는 Stop the world - Mark and sweep(이 알고리즘 외에도 Mark and compact (-> Major GC에서 사용한다고 함) 알고리즘이 있다고 하는데 너무 얕게 알고 있었던 것 같습니다.) 로 일어납니다. 먼저 Stop the world는 GC를 제외한 모든 쓰레드들을 일시 정지 하는 과정입니다. Mark and sweep는 참조되는 객체에 대해 마크를 한 이후 이후 마크되지 않는 객체들을 추적해서 삭제를 하는 과정입니다.

GC의 정의와 GC가 왜 일어나고 Minor과 Major GC가 정확히 어떻게 일어나는지에 대해 간략하게라도 설명했으면 좋았을 것 같다.

이외에도 GC의 알고리즘에 대해 대략적으로 공부해 보는 것도 좋을 것 같다.

---

### Q2. JVM의 구조와 역할에 관해 설명하시오
{꼬리 질문 : 런타임 데이터 에리아는 메모리 영역인데 이것의 구조를 설명하시오}
### A2.  답변
GC, 클래스 로더, 런라임 데이터 에리아, 익세큐트 엔진이 있다. 각각의 역할은 다음과 같다. 
- GC - 사용 안 된 메모리를 제거합니다.
- 이그제큐티브 엔진- 바이트 코드를 명령어 단위로 실행하는 역할을 한다.
- 런타임 데이터 에리아 - 데이터를 나열하는 역할을 한다.
- 클래스 로더 - 답변 X
#### 꼬리질문 답변 
클래스 , 힙, 스태틱 영역이 있다.
스태틱 : 시작부터 끝까지 유지되는 영역이다
힙 : 객체 할당하는 영역이다
클래스 영역: 설명 X
### Q&A2. 점수
* 질문자 점수: 2.5점
* 답변자 점수: {1~5점}

### Q&A2. 피드백
- 질문자 피드백: 1번 질문처럼 각 모듈의 핵심 기능은 잘 알고 있는 듯하나 간단하게 암기했다는 느낌이 들었고 클래스 로더 부분은 답변을 못 했다는 점에서 아쉬움. 꼬리질문의 경우 스택 영역을 클래스 영역이라고 잘못 언급한 부분이 아쉬움
- 답변자 피드백: 
- 그룹 피드백: 

### AS2. 개선 답변
{답변자가 부족한 점이나 아쉬운 점, 또는 피드백을 받은 점이 있었다면 좀 더 개선된 답변을 작성.}

새로운 답변 ⬇️⬇️

> 이 부분에 대해 깊은 공부가 필요하다는 것을 느끼게 되었다.
JVM이란 자바 바이트 코드를 수행할 수 있는 주체로 Class Loader, Excute Engine, Garbage Collector, Runtime Data Areas가 있다. 
Class Loader는 JVM내로 class 를 로드하고 Link를 통해 적절히 배치하는 일련의 작업을 수행하는 모듈입니다.
ExcuteEngine은 class loader를 통해 Runtime data area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다.
Garbage Collector는 힙 영역에 할당 되지 않는 객체들을 정리합니다.
Runtime data area는 JVM이라는 프로그램이 할당 받는 메모리 영역으로 총 6개의 영역으로 나뉘어집니다.

꼬리질문에 대한 새로운 답변 ⬇️⬇️

> Method(static Area), Heap Area, Stack Area, Runtime Constant pool, PC Register, Native Method Stack Area으로 구성되어 있다.
먼저 PC Register는 쓰레드가 생성될 때 마다 생기는 공간으로 Thread가 어떠한 명령을 실행하게 될지에 대한 부분을 기록합니다.
Method Area는 JVM이 클래스 파일을 읽어들여 클래스의 인스턴트 변수, 메소드 등을 Method Area에 저장합니다.
Heap 영역은 사용자가 관리하는 인스턴스가 생성되는 공간으로 객체를 동적으로 생성하면 인스턴스는 힙 영역에 할당됩니다.
JVM 스택은 쓰레드 제어를 위한 메모리 영역으로 쓰레드 생성시마다 하나씩 생성되며 단일 쓰레드당 Method가 호출될 때 메모리를 차지하게 됩니다.
Native Method Stack Area는 JNI를 호출하는 C/C+ 등을 코드를 수행하기 위한 스택입니다.


---

### Q3. 객체지향 프로그래밍의 특징 4 가지에 대해 설명하시오


### A3. 답변
- 추상화: 구체적X 추상적으로 구현한다
- 상속성: 자식 클래스가 부모 클래스를 상속받아 부모 내용을 사용한다는 것을 의미
- 다형성: 같은 내용을 여러가지 의미로 나타내도록 Animal = new cat()처럼 여러가지로 해석할 수 있다는 것을 의미.
- 캡슐화: 비슷한 내용을 다루는 데이터 클래스를 하나로 뭉치는 것을 의미


### Q&A3. 점수
* 질문자 점수: 3.0
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 각 특징을 거의 한 문장으로 설명하여 충분히 설명이 되지 않음. 다형성의 예시로 든 부분은 코드를 그대로 말하기 보다는 비유하는 식으로 설명하는 것이 좋을 듯 함. 
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변

---

### Q4. 스프링 Bean 의 생명주기에 대해서 설명하시오

### A3. 답변
ioc 컨테이너에서 생성되고 의존관계를 주입, 초기화, 삭제 과정이 이루어 진다. 초기화란 초기화 소멸과정은 이벤트로 발생한다. 


### Q&A3. 점수
* 질문자 점수: 3.0점
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 본인이 이 부분에 대한 공부가 부족해 배경 지식이 부족했는데 답변을 듣고 이해가 잘 되지 않았음. 질문에 대한 답변을 부분적으로 외워 말하는 것 같은 느낌이 들었음. 
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변
{답변자가 부족한 점이나 아쉬운 점, 또는 피드백을 받은 점이 있었다면 좀 더 개선된 답변을 작성.}

---

### Q5. 스프링과 스프링 부트의 차이점을 설명하시오

### A3. 답변
 정확한 워딩은 기억이 나지 않음
 의존성을 주입한다, 톰캣이 존재하기에 배포하기가 쉽다라고만 설명했던 것으로 기억함

### Q&A3. 점수
* 질문자 점수: 2.5점
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 스프링과 스프링부트의 차이점을 비교하면서 설명하는 것을 기대했으나 의존성을 주입한다는 것은 두 가지가 동일하고 어떻게 하는지에 대한 차이점을 설명해주지 않았음. 톰캣이 존재한다고 언급하고 그것이 어떻게 배포를 쉽게 하는지를 설명해주었으면 함. 추가로 다른 차이점들로 답변에 넣었으면 좋겠다고 생각함(총 3가지 정도)
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변

---

### Q6. 웹 서버 개발에서 로그인 세션 처리 , 권한체크 , XSS 방어 같은 공통 기능을 하는 코드는 어떻
게 처리하는지 설명하시오 (filter, interceptor, AOP 등등)


### A3. 답변
따로 메모를 하지 못해 기억나는대로 작성
필터가 무엇인지 설명하고 인터프리터도 무엇인지 설명, AOP가 무엇인지 각각의 정의에 대해서만 짧게 설명하고 끝남.

### Q&A3. 점수
* 질문자 점수: 2.5
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 공통 기능을 처리한다는 측면에서 각 요소를 설명해 주었으면 어땠을까 하는 피드백을 드립니다. 
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변


---

### Q7. JPA의 기본키 생성 방식의 종류와 이에 대하여 아는 대로 설명하시오

### A3. 답변
- 기본키 생성 방식 4가지에 대하여 언급하고 이에 대한 설명을 차이점을 언급하며 설명함.

### Q&A3. 점수
* 질문자 점수: 4.0점
* 답변자 점수: 

### Q&A3. 피드백
- 질문자 피드백: 해당 부분은 설명을 잘 해주심. 내용을 조금 더 정리하여 부드럽게 이어지도록 연습을 하면 좋을 듯 함
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변


---

### Q8. 영속성 컨텍스트 (Persistence) 의 개념을 설명하시오
    (꼬리질문: 영속성 컨텍스트를 사용하는 근본적인 이유)
### A3. 답변
영속성 컨텍스트에 대한 설명이 제대로 되지 않았던 것으로 기억함
꼬리질문 또한 답변하지 못 함
### Q&A3. 점수
* 질문자 점수: 2.3점
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 영속성 컨텍스트의 개념과 유용성을 다시 한번 정리하여 답변을 작성해주시면 좋을 것 같습니다. 
- 답변자 피드백: {답변자 스스로 피드백한 내용 작성}
- 그룹 피드백: "{전체 피드백 시간 감상}"(성주), "{전체 피드백 시간 감상}"(찬일)

### AS3. 개선 답변
{답변자가 부족한 점이나 아쉬운 점, 또는 피드백을 받은 점이 있었다면 좀 더 개선된 답변을 작성.}

---

### Q9. 엔티티 매니저에 관해 설명하시오

### A3. 답변
답변 없음
### Q&A3. 점수
* 질문자 점수: 
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 다시 답변을 작성해주시면 좋을 듯함
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변

---

### Q10. 트랜잭션의 격리 레벨 (Isolation 에 관해 설명 하시오


### A3. 답변
총 4가지 단계가 존재, 언커미티드, 커미티드, 리피터블, 시리얼라이제이션이 있다.

언커미티드- 커밋이 안되어도 데이터를 가져올 수 있다.
커미티드 - 커밋되어야 데이터를 가져올 수 있게된다, 
리피터블 - 기억 X
시리얼라지제이션 - 커밋 이후에 차례대로 접근 가능한 것으로 가장 엄격한 격리 방식, 성능이 가장 떨어진다. 

### Q&A3. 점수
* 질문자 점수: 3.0점 
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 설명해주시는 내용을 듣긴 하였으나 답변 만으로는 이해하기가 어려움. 문장을 외웠으나 부분적으로나 기억이 나 답변하는 듯한 느낌이 들었음. 시리얼라이제이션 답변도 좋았으나 어떻게 엄격한지 왜 성능이 떨어지는 등을 설명해 주셨으면 좋겠음.
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변

---

### Q11.더티 리스에 대해 설명하시오 

### A3. 답변
커밋하기 이전의 기록과 커밋 이후의 기록이 달라서 발생하는 리드

### Q&A3. 점수
* 질문자 점수: 2.5점
* 답변자 점수: {1~5점}

### Q&A3. 피드백
- 질문자 피드백: 설명이 너무 짧음. 마찬가지로 설명이 좀 더 들어갔으면 좋겠음. 
- 답변자 피드백: 
- 그룹 피드백: 

### AS3. 개선 답변
